import UIKit

final class SiteMediaCollectionCellViewModel {
    var onImageLoaded: ((UIImage) -> Void)?
    @Published private(set) var overlayState: CircularProgressView.State?
    @Published private(set) var durationText: String?
    @Published var badgeText: String?
    let mediaID: TaggedManagedObjectID<Media>
    var mediaType: MediaType

    private let media: Media
    private let service: MediaImageService
    private let cache: MemoryCache
    private var isVisible = false
    private var isPrefetchingNeeded = false
    private var imageTask: Task<Void, Never>?
    private var observations: [NSKeyValueObservation] = []

    deinit {
        imageTask?.cancel()
    }

    init(media: Media,
         service: MediaImageService = .shared,
         cache: MemoryCache = .shared) {
        self.mediaID = TaggedManagedObjectID(media)
        self.media = media
        self.mediaType = media.mediaType
        self.service = service
        self.cache = cache

        if media.mediaType == .video || media.mediaType == .audio {
            observations.append(media.observe(\.length, options: [.initial, .new]) { [weak self] media, _ in
                // Using `rounded()` to match the behavior of the Photos app
                self?.durationText = makeString(forDuration: media.duration().rounded())
            })
        }

        observations.append(media.observe(\.remoteStatusNumber, options: [.new]) { [weak self] _, _ in
            self?.updateOverlayState()
        })

        // No sure why but `.initial` didn't work.
        self.updateOverlayState()

        observations.append(media.observe(\.localURL, options: [.new]) { [weak self] media, _ in
            self?.didUpdateLocalThumbnail()
        })
    }

    // MARK: - View Lifecycle

    func onAppear() {
        guard !isVisible else { return }
        isVisible = true
        fetchThumbnailIfNeeded()
    }

    func onDisappear() {
        guard isVisible else { return }
        isVisible = false
        cancelThumbnailRequestIfNeeded()
    }

    func startPrefetching() {
        guard !isPrefetchingNeeded else { return }
        isPrefetchingNeeded = true
        fetchThumbnailIfNeeded()
    }

    func cancelPrefetching() {
        guard isPrefetchingNeeded else { return }
        isPrefetchingNeeded = false
        cancelThumbnailRequestIfNeeded()
    }

    // MARK: - Thumbnail

    private func fetchThumbnailIfNeeded() {
        guard isVisible || isPrefetchingNeeded else {
            return
        }
        guard imageTask == nil else {
            return // Already loading
        }
        guard getCachedThubmnail() == nil else {
            return // Already cached  in memory
        }
        imageTask = Task { @MainActor [service, media, weak self] in
            do {
                let image = try await service.thumbnail(for: media)
                self?.didFinishLoading(with: image)
            } catch {
                self?.didFinishLoading(with: nil)
            }
        }
    }

    private func cancelThumbnailRequestIfNeeded() {
        guard !isVisible && !isPrefetchingNeeded else { return }
        imageTask?.cancel()
        imageTask = nil
    }

    private func didFinishLoading(with image: UIImage?) {
        if let image {
            cache.setImage(image, forKey: makeCacheKey(for: media))
        }
        if !Task.isCancelled {
            if let image {
                onImageLoaded?(image)
            }
            imageTask = nil
        }
    }

    /// Returns the image from the memory cache.
    func getCachedThubmnail() -> UIImage? {
        cache.getImage(forKey: makeCacheKey(for: media))
    }

    private func makeCacheKey(for media: Media) -> String {
        "thumbnail-\(media.objectID)"
    }

    // Monitors thumbnails generated by `MediaImportService`.
    private func didUpdateLocalThumbnail() {
        guard media.remoteStatus != .sync, media.localURL != nil else { return }
        fetchThumbnailIfNeeded()
    }

    // MARK: - State

    private func updateOverlayState() {
        switch media.remoteStatus {
        case .pushing, .processing:
            self.overlayState = .indeterminate
        case .failed:
            self.overlayState = .retry
        case .sync:
            self.overlayState = nil
        default:
            break
        }
    }
}

// MARK: - Helpers (Duration Formatter)

private func makeString(forDuration duration: TimeInterval) -> String? {
    let hours = Int(duration / 3600)
    if hours > 0 {
        return longDurationFormatter.string(from: duration)
    } else {
        return shortDurationFormatter.string(from: duration)
    }
}

private let longDurationFormatter = makeFormatter(units: [.hour, .minute, .second])
private let shortDurationFormatter = makeFormatter(units: [.minute, .second])

private func makeFormatter(units: NSCalendar.Unit) -> DateComponentsFormatter {
    let formatter = DateComponentsFormatter()
    formatter.zeroFormattingBehavior = .pad
    formatter.allowedUnits = units
    return formatter
}
