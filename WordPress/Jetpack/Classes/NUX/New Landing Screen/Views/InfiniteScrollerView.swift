import UIKit

/// A scroll view that produces an infinite scrolling effect.
///
/// Set the `scrollerDelegate` property to externally alter the scrolling rate speed and direction.
///
/// By default user interaction with the scroll view is disabled, but it can be enabled if desired.
///
/// Currently the view only supports vertical scrolling, but could easily be updated to support horizontal.
/// This class also currently makes the assumption that the view generated by the `viewBuilder` closure will be taller
/// than its frame.
class InfiniteScrollerView: UIScrollView {
    /// Delegate to poll for the speed and direction of the scrolling offset. Polled at the default rate of `CADisplayLink`.
    weak var scrollerDelegate: InfiniteScrollerViewDelegate?

    private var displayLink: CADisplayLink?

    /// Closure used to repeat a view to populate a `UIStackView` for scrolling.
    /// Provides the index of the view in the `UIStackView`.
    private var viewBuilder: ((Int) -> UIView)?
    private var stackView: UIStackView?

    /// Returns the height of the first view in the stack view, if one exists. Used to compute reset points for vertical scrolling.
    private var singleViewHeight: CGFloat? {
        guard
            let stackView = stackView,
            !stackView.arrangedSubviews.isEmpty
        else {
            return nil
        }

        return stackView.arrangedSubviews[0].frame.size.height
    }

    /// Initializes a view that produces an infinite scrolling effect.
    /// - Parameter viewBuilder: Closure that generates a `UIView`. Repeatedly called to fill a `UIStackView` that will be scrolled.
    convenience init(_ viewBuilder: @escaping ((Int) -> UIView)) {
        self.init()
        self.viewBuilder = viewBuilder
        displayLink = CADisplayLink(target: self, selector: #selector(step))

        setupScrollView()
        let stackView = setupStackView()
        addSubview(stackView)

        pinSubviewToAllEdges(stackView)
        stackView.widthAnchor.constraint(equalTo: widthAnchor).isActive = true

        self.stackView = stackView
        addViewsToStackView()

        displayLink?.add(to: .current, forMode: .default)
    }

    private func addViewsToStackView() {
        guard
            let viewBuilder = viewBuilder,
            let stackView = stackView
        else {
            return
        }

        /// Note: This class makes the assumption that the view generated by `viewBuilder()` is taller than
        /// the scroll view's frame. To support views shorter than the frame it'd need to calculate how many times
        /// to repeat it based on the built view's height.
        ///
        /// Currently, five views are generated because of an even / odd congruency requirement by the JetpackLandingScreen.
        for i in 0...4 {
            stackView.addArrangedSubview(viewBuilder(i))
        }
    }

    private func setupScrollView() {
        delegate = self
        bounces = false
        showsVerticalScrollIndicator = false
        showsHorizontalScrollIndicator = false
        isUserInteractionEnabled = false
    }

    private func setupStackView() -> UIStackView {
        let stackView = UIStackView()
        stackView.axis = .vertical
        stackView.distribution = .fillEqually
        stackView.spacing = 0
        stackView.translatesAutoresizingMaskIntoConstraints = false

        return stackView
    }

    /// Called on each `CADisplayLink` frame and sets the vertical content offset if a scroller delegate is set.
    @objc private func step() {
        guard
            let scrollerDelegate = self.scrollerDelegate,
            let singleViewHeight = self.singleViewHeight,
            // the rate shouldn't be higher than the size of the view
            scrollerDelegate.rate < singleViewHeight
        else {
            return
        }

        contentOffset.y += scrollerDelegate.rate
    }
}

extension InfiniteScrollerView: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        guard let singleViewHeight = self.singleViewHeight else {
            return
        }

        let yOffset = contentOffset.y

        /// Note: These offsets were chosen to be congruent with the JetpackLandingScreen, where
        /// a matching view exists every other view (evens and odds). For views without this requirement,
        /// fewer could be generated and efficiency increased.
        if yOffset >= singleViewHeight * 4 {
            contentOffset.y -= singleViewHeight * 2
        } else if yOffset <= singleViewHeight {
            contentOffset.y += singleViewHeight * 2
        }
    }
}
